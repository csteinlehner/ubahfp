package hexlib;

import java.util.Vector;

public class Grid {
	
int cols;
int rows;

Vector<Hex> hexes = new Vector<Hex>();

public Grid(int cols, int rows){
	
	  this.cols = cols;
	  this.rows = rows;

}
	
public Area to_area(){
	
    for(int i=0; i<cols; ++i){
        for(int j=0; j<rows; ++j){
            hexes.add(hex(i,j));
        }  
    }          
    return new Area(hexes);
  }

public Hex hex(int a, int b){
return new Hex(this, a,b);	
}	


/** A square field of hexagons that form the universe in which the other
 *  objects exist. */
//HEX.Grid = function(cols,rows)
//{
//  if(0>cols || cols>=0x4000)
//      throw HEX.out_of_range("cols");
//  if(0>rows || rows>=0x4000)
//      throw HEX.out_of_range("rows");
//  this._hexes = {};
//  this.cols = cols;
//  this.rows = rows;
//}

//HEX.Grid.prototype = {

//  to_area : function()
//    {
//      var hexes = [];
//      for(var i=0; i<this.cols; ++i)
//          for(var j=0; j<this.rows; ++j)
//              hexes.push( this.hex(i,j) );
//      HEX.uniq(hexes);
//      return new HEX.Area(hexes);
//    },

  // factory methods

//  hex : function(a,b)
//    {
//      return new HEX.Hex(this,a,b);
//    },

//  /** Parse strings generated by set_str()
//   *  @return  sorted Array of unique HEX.Hex objects */
//  hexes : function(str)
//    {
//      var result = [];
//      var piece =str.split(' ');
//      for(var i=0, len=piece.length; i<len; ++i)
//        result.push( this.hex(piece[i]) );
//      HEX.uniq(result);
//      return result;
//    },

  /** Parse strings generated by Area::str()
   *  @return  object of type HEX.Area */
//  area : function(str)
//    {
//      // Parse string of area fillpaths
//      // E.g. 1_2>CDE:ABC
//      var result = [];
//      var pos =str.search(/[>:]/);
//      if(pos<0)
//          throw HEX.invalid_argument(str+' [1]');
//      var origin =this.hex( str.substr(0,pos) );
//      var start  =origin;
//      while(pos>=0)
//      {
//        var next =this._str_find(str,/[>:]/,pos+1);
//        var steps =str.substr( pos+1, (next<0)?(str.length):(next-pos-1) );
//        if(str.charAt(pos)==='>')
//        {
//          start=origin.go(steps);
//        }
//        else // ':'
//        {
//          var path =new HEX.Path(start,steps);
//          result = HEX.set_union(result,path.hexes);
//          start=origin;
//        }
//        pos=next;
//      }
//      return new HEX.Area(result);
//    },

//  /** Parse strings generated by Path::str()
//   *  @return  object of type HEX.Path */
//  path : function(str)
//    {
//      var colon =str.indexOf(':');
//      if(colon<=0 || (colon+1)>=str.length)
//          throw HEX.invalid_argument(s);
//      var origin =this.hex( str.substr(0,colon) );
//      return new HEX.Path(origin,str.substr(colon+1));
//    },

  // String utility
//  
//  /** Like String.indexOf, except it takes a regular expression. */
//  _str_find : function(haystack,needle,start_pos)
//    {
//      var s =haystack.substr(start_pos);
//      var pos =s.search(needle);
//      if(pos<0)
//        return pos;
//      else
//        return start_pos+pos;
//    }
//
//};





}
